import typer
import json
import logging
from pathlib import Path
from datetime import datetime

app = typer.Typer()
ROOT = Path("~/0luka").expanduser()

logging.basicConfig(level=logging.INFO, format='[MOCK-ENGINE] %(message)s')

@app.command()
def activate(job_path: str):
    """
    Simulates a compliant Massing Engine (Mock).
    Copy-cats the Nano Banana interface but does nothing expensive.
    """
    job_path = Path(job_path)
    if not job_path.exists():
        logging.error(f"‚ùå ABORT: Job file {job_path} missing.")
        return

    with open(job_path, 'r') as f:
        job = json.load(f)

    job_id = job.get("job_id", "UNKNOWN")
    prompt = job.get("parameters", {}).get("prompt", "")
    logging.info(f"ü§ñ ACTIVE MOCK SYNTHESIS FOR {job_id}...")
    
    if "SLEEP" in prompt:
        import time
        import re
        match = re.search(r"SLEEP_TEST_(\d+)s", prompt)
        secs = int(match.group(1)) if match else 10
        logging.info(f"‚è≥ Sleeping {secs}s for load testing...")
        time.sleep(secs)

    # Create a dummy artifact
    output_dir = ROOT / "modules" / "studio" / "outputs"
    output_dir.mkdir(parents=True, exist_ok=True)
    
    artifact_path = output_dir / f"mock_artifact_{job_id}.txt"
    with open(artifact_path, 'w') as f:
        f.write(f"This is a mock artifact for job {job_id}.\nGenerated by mock_engine_v1.")

    # Create Manifest
    result_metadata = {
        "status": "COMPLETED",
        "job_id": job_id,
        "render_time": "0.1s",
        "output_url": f"assets/renders/{job_id}_mock.txt", # Ignored by adapter but kept for shape
        "metadata": {
            "engine": "mock_engine_v1",
            "timestamp": datetime.now().isoformat()
        }
    }
    
    result_path = output_dir / f"result_{job_id}.json"
    with open(result_path, 'w') as f:
        json.dump(result_metadata, f, indent=2)

    logging.info(f"‚ú® MOCK COMPLETE. Manifest: {result_path.name}")

if __name__ == "__main__":
    app()
